// Generated by LiveScript 1.3.1
var fs, os, hu, path, crypto, status, Buffer, rm, mk, findup, normalize, join, dirname, basename, delimiter, extname, env, platform, exit, nextTick, arch, _;
fs = require('fs');
os = require('os');
hu = require('hu');
path = require('path');
crypto = require('crypto');
status = require('./status');
Buffer = require('buffer').Buffer;
rm = require('rimraf');
mk = require('mkdirp');
findup = require('findup-sync');
normalize = path.normalize, join = path.join, dirname = path.dirname, basename = path.basename, delimiter = path.delimiter, extname = path.extname;
env = process.env, platform = process.platform, exit = process.exit, nextTick = process.nextTick, arch = process.arch;
module.exports = _ = {
  path: path,
  platform: platform,
  arch: arch,
  extend: hu.extend,
  vals: hu.vals,
  EOL: os.EOL,
  clone: hu.clone,
  isObject: hu.isObject,
  isArray: hu.isArray,
  isString: hu.isString,
  has: hu.has,
  delimiter: delimiter,
  echo: function(it){
    if (it) {
      return console.log.apply(this, arguments);
    } else {
      return console.log('');
    }
  },
  rm: rm.sync,
  mk: mk.sync,
  next: nextTick,
  env: function(it){
    return env[it] || null;
  },
  now: function(){
    return new Date().getTime();
  },
  isWin: platform === 'win32',
  toKb: function(it){
    if (it) {
      return Math.round(it / 1024) || 1;
    } else {
      return 0;
    }
  },
  exists: function(it){
    return it && fs.existsSync(
    normalize(
    it));
  },
  stringify: function(it){
    if (it) {
      return JSON.stringify(it, null, 2);
    }
  },
  keys: function(it){
    if (hu.isObject(
    it)) {
      return Object.keys(
      it);
    } else {
      return [];
    }
  },
  tmpdir: function(name){
    name == null && (name = 'pkg');
    name = basename(name, extname(
    name));
    return join(os.tmpdir(), "nar-" + name + "-" + _.random());
  },
  addExtension: function(it){
    if (it && !_.isUrl(
    it)) {
      if (!/.nar$/.test(it)) {
        it += '.nar';
      }
    }
    return it;
  },
  isDir: function(it){
    return _.exists(
    it) && fs.lstatSync(
    normalize(
    it)).isDirectory();
  },
  isLink: function(it){
    return fs.lstatSync(
    normalize(
    it)).isSymbolicLink();
  },
  isFile: function(it){
    return _.exists(
    it) && (fs.lstatSync(
    normalize(
    it)).isFile() || _.isLink(
    it));
  },
  random: function(){
    return _.now() + Math.floor(Math.random() * 10000);
  },
  lines: function(it){
    if (it) {
      return it.split(os.EOL);
    }
  },
  isUrl: function(it){
    return /^http[s]?\:/.test(
    it);
  },
  httpStatus: function(code){
    if (code) {
      return code + " " + (status[code] || '');
    } else {
      return '';
    }
  },
  replaceEnvVars: function(str){
    return str.replace(/\$\{(\w+)\}/ig, function(_, name){
      return process.env[name] || '';
    });
  },
  logError: function(err, debug){
    if (err) {
      if (debug && err.stack) {
        return err.stack;
      } else {
        return ("Error: " + (err.message || err)).red;
      }
    }
  },
  exit: function(code){
    if (code === 0 || !code) {
      exit(
      code);
    }
    return function(message){
      if (message != null) {
        if (String.prototype.red != null) {
          message = message.red;
        }
        _.echo(
        message);
      }
      return exit(
      code);
    };
  },
  read: function(it){
    var data;
    if (_.exists(
    it)) {
      data = fs.readFileSync(
      normalize(
      it)).toString();
      if (/.json$/.test(
      it)) {
        return JSON.parse(
        data);
      } else {
        return data;
      }
    } else {
      return null;
    }
  },
  write: function(path, data){
    if (path) {
      return fs.writeFileSync(path, data);
    }
  },
  once: function(cb){
    var error;
    error = false;
    return function(it){
      if (!error) {
        cb.apply(this, arguments);
      }
      if (it) {
        return error = true;
      }
    };
  },
  discoverPkg: function(dir){
    dir == null && (dir = process.cwd());
    return findup('package.json', {
      cwd: dir
    });
  },
  handleExit: function(cb){
    var listener;
    listener = function(){
      process.stdin.resume();
      cb();
      return process.removeListener('SIGINT', listener);
    };
    return process.on('SIGINT', listener);
  },
  isExecutable: function(path){
    var buffer, num, data;
    buffer = new Buffer(25);
    num = fs.readSync(fs.openSync(path, 'r'), buffer, 0, 25, 0);
    data = buffer.toString('utf-8', 0, num);
    return /^\#\!\/bin\/bash/.test(data) && /\#\#nar\#\#/.test(data);
  },
  executableMsg: function(file){
    file = basename(
    file || 'sample.nar');
    if (_.isWin) {
      return "the nar file is an executable, you cannot run it in Windows";
    } else {
      return "the nar file is an executable, you must run it as binary:\n\n  Example:\n  $ chmod +x " + file + "\n  $ ./" + file + " exec --port 8080 --verbose\n\nYou could use the exec, start, extract, install or list commands\nFor more usage information, see the docs at github.com/h2non/nar";
    }
  },
  archiveName: function(nar){
    var name, version;
    name = '';
    if (nar) {
      name += nar.name || 'unnamed';
      if (version = nar.manifest.version) {
        name += "-" + version;
      }
      if (nar.binary) {
        name += "-" + platform + "-" + arch;
      }
    }
    return name + ".nar";
  },
  checksum: function(file, cb){
    var hash;
    hash = crypto.createHash('sha1');
    return fs.createReadStream(
    file).on('data', (function(it){
      return hash.update(it);
    })).on('end', function(){
      return cb(null, hash.digest('hex'));
    }).on('error', cb);
  },
  rename: function(orig, filename, cb){
    var base;
    base = dirname(
    orig);
    return fs.rename(orig, join(base, filename), cb);
  },
  copy: function(file, dest, cb){
    var filename;
    filename = basename(
    file);
    dest = join(dest, filename);
    return fs.createReadStream(
    file).pipe(fs.createWriteStream(dest)).on('close', function(){
      return cb(null, dest);
    }).on('error', cb);
  },
  copyBinary: function(file, dest, cb){
    return _.copy(file, dest, function(err, output){
      var name;
      if (err) {
        return cb(
        err);
      }
      if ((name = basename(
      file)) !== 'node') {
        return _.rename(output = join(dirname(
        output), name), 'node', function(err){
          if (err) {
            return cb(
            err);
          }
          return cb(null, output);
        });
      } else {
        return cb(null, output);
      }
    });
  },
  winBinaryScript: function(path){
    path = normalize(
    path);
    return "@ECHO OFF\n@IF EXIST \"%~dp0\\node.exe\" (\n  \"%~dp0\\node.exe\" \"" + path + "\" %*\n) ELSE (\n  node \"" + path + "\" %*\n)";
  }
};
