// Generated by LiveScript 1.3.1
var fs, fw, path, pack, utils, resolve, EventEmitter, ref$, dirname, basename, join, normalize, read, rm, tmpdir, clone, extend, copyBinary, keys, archiveName, isObject, isFile, isDir, isLink, isString, mk, stringify, vals, exists, checksum, lines, next, isArray, now, replaceEnvVars, discoverPkg, handleExit, once, isWin, BINDIR, narFile, ext, ignoredFiles, ignoreFiles, defaults, create, writeConfig, narManifest, includeFilesPatterns, getIgnoredFiles, isValid, outputFile, getFilename, applyPkgOptions, apply, resolvePkgPath, getBinaryPath, getModulePath, matchDependencies;
fs = require('fs');
fw = require('fw');
path = require('path');
pack = require('./pack');
utils = require('./utils');
resolve = require('requireg').resolve;
EventEmitter = require('events').EventEmitter;
ref$ = require('path'), dirname = ref$.dirname, basename = ref$.basename, join = ref$.join, normalize = ref$.normalize;
read = utils.read, rm = utils.rm, tmpdir = utils.tmpdir, clone = utils.clone, extend = utils.extend, copyBinary = utils.copyBinary, keys = utils.keys, archiveName = utils.archiveName, isObject = utils.isObject, isFile = utils.isFile, isDir = utils.isDir, isLink = utils.isLink, isString = utils.isString, mk = utils.mk, stringify = utils.stringify, vals = utils.vals, exists = utils.exists, checksum = utils.checksum, lines = utils.lines, next = utils.next, isArray = utils.isArray, now = utils.now, replaceEnvVars = utils.replaceEnvVars, discoverPkg = utils.discoverPkg, handleExit = utils.handleExit, once = utils.once, isWin = utils.isWin;
BINDIR = '_modules-bindir';
narFile = '.nar.json';
ext = 'nar';
ignoredFiles = ['!node_modules/**'];
ignoreFiles = ['.gitignore', '.npmignore', '.buildignore', '.narignore'];
defaults = {
  path: null,
  binary: false,
  binaryPath: process.execPath,
  dependencies: true,
  devDependencies: false,
  peerDependencies: true,
  globalDependencies: null,
  patterns: null,
  ignoreFiles: true
};
module.exports = create = function(options){
  var errored, emitter, pkgPath, pkg, name, tmpPath, baseDir, file, output, clean, cleanError, onError, onEntry, onEnd, doCreate, compressAll, compressPkg, compressDependencies, e;
  errored = false;
  emitter = new EventEmitter;
  options = apply(
  options);
  pkgPath = options.path;
  if (pkgPath) {
    pkg = read(
    pkgPath);
  }
  if (pkg) {
    options = applyPkgOptions(options, pkg);
  }
  if (!pkg) {
    throw new Error('Cannot find package.json');
  }
  name = pkg.name || 'unnamed';
  tmpPath = tmpdir(name);
  options.base = baseDir = dirname(
  pkgPath);
  file = getFilename(options, pkg);
  output = outputFile(file, options.dest);
  clean = function(){
    emitter.emit('message', 'Cleaning temporary directories');
    try {
      return rm(tmpPath);
    } catch (e$) {}
  };
  cleanError = function(){
    clean();
    try {
      return rm(output);
    } catch (e$) {}
  };
  onError = once(function(err){
    cleanError();
    if (!errored) {
      emitter.emit('error', err);
    }
    return errored = true;
  });
  onEntry = function(it){
    if (it) {
      return emitter.emit('entry', it);
    }
  };
  onEnd = function(){
    clean();
    if (!errored) {
      return emitter.emit('end', output);
    }
  };
  doCreate = function(){
    return next(function(){
      var narConfig, deps, basePkg, all, doCompression, onCompress;
      handleExit(
      cleanError);
      narConfig = narManifest(name, pkg);
      emitter.emit('start', narConfig);
      emitter.emit('info', narConfig);
      deps = function(done){
        return compressDependencies(tmpPath, baseDir, function(err, files){
          if (err) {
            return onError(
            err);
          }
          if (files) {
            narConfig.files = narConfig.files.concat(files);
          }
          return done();
        });
      };
      basePkg = function(done){
        var config;
        config = {
          dest: tmpPath,
          base: baseDir,
          name: name,
          patterns: options.patterns
        };
        return compressPkg(config, function(it){
          narConfig.files.push(
          it);
          return done();
        });
      };
      all = function(done){
        return compressAll(narConfig, done);
      };
      doCompression = function(done){
        mk(
        tmpPath);
        return fw.series([deps, basePkg, all], done);
      };
      onCompress = function(err){
        if (err) {
          return onError(
          err);
        }
        return onEnd();
      };
      return doCompression(
      onCompress);
    });
  };
  compressAll = function(narConfig, cb){
    var config, packAll, saveConfig, exec, addBinary;
    config = {
      name: file,
      dest: options.dest,
      patterns: ['*.tar', narFile],
      src: tmpPath,
      ext: 'nar',
      gzip: true
    };
    packAll = function(done){
      return pack(config).on('error', done).on('entry', onEntry).on('end', function(){
        return done();
      });
    };
    saveConfig = function(done){
      return writeConfig(narConfig, tmpPath, done);
    };
    exec = function(){
      return fw.series([saveConfig, packAll], cb);
    };
    addBinary = function(){
      var binaryPath, pkgInfo;
      binaryPath = options.binaryPath;
      if (!isFile(
      binaryPath)) {
        return onError(
        new Error("Binary path do not exists: " + binaryPath));
      }
      pkgInfo = {
        name: 'node',
        archive: 'node',
        dest: '.node/bin',
        type: 'binary'
      };
      emitter.emit('archive', pkgInfo);
      return copyBinary(binaryPath, tmpPath, function(err, file){
        if (err) {
          return onError(
          new Error("Error while copying the node binary: " + err));
        }
        config.patterns.push(
        basename(
        file));
        onEntry(
        {
          name: pkgInfo.archive,
          type: pkgInfo.type,
          size: '10485760',
          sourcePath: binaryPath
        });
        return checksum(file, function(err, hash){
          pkgInfo.checksum = hash;
          narConfig.files.push(
          pkgInfo);
          return exec();
        });
      });
    };
    if (options.binary && !options.executable) {
      narConfig.binary = true;
      return addBinary();
    } else {
      return exec();
    }
  };
  compressPkg = function(config, cb){
    var ref$, dest, base, name, patterns, pkgInfo, onPackEnd;
    ref$ = config = clone(
    config), dest = ref$.dest, base = ref$.base, name = ref$.name, patterns = ref$.patterns;
    config.patterns = patterns.concat(includeFilesPatterns(base, options.ignoreFiles));
    config.src = base;
    pkgInfo = {
      name: name,
      archive: name + ".tar",
      dest: '.',
      type: 'package'
    };
    emitter.emit('archive', pkgInfo);
    onPackEnd = function(pkg){
      return checksum(pkg.path, function(err, hash){
        pkgInfo.checksum = hash;
        return cb(pkgInfo);
      });
    };
    return pack(config).on('error', function(it){
      throw it;
    }).on('entry', onEntry).on('end', onPackEnd);
  };
  compressDependencies = function(dest, base, cb){
    var files, globals, addBinDirectory, getPkgPath, findPkg, calculateChecksum, definePkgBindirInfo, definePkgDependencyInfo, definePkgInfo, doPack, compressDepPkgs, findGlobal, processGlobal, processDeps, dependenciesList, list;
    files = [];
    globals = [];
    addBinDirectory = function(it){
      var binDir, links;
      binDir = join(base, getModulePath(
      '.bin'));
      if (isDir(
      binDir)) {
        links = {};
        fs.readdirSync(
        binDir).filter(function(it){
          return !/^\./.test(it);
        }).filter(function(it){
          return it !== 'Thumbs.db';
        }).forEach(function(file){
          var linkPath;
          if (isWin) {
            return links[file] = join(join(binDir, '..', file, 'bin', file), file), links;
          } else {
            linkPath = join(binDir, file);
            if (isLink(
            linkPath)) {
              return links[file] = fs.readlinkSync(
              linkPath), links;
            }
          }
        });
        return it.push(
        {
          name: BINDIR,
          src: binDir,
          dest: dest,
          links: links
        });
      }
    };
    getPkgPath = function(name){
      var path;
      path = join(base, getModulePath(
      name));
      if (!isFile(
      join(path, 'package.json'))) {
        throw new Error("Missing required dependency in node_modules: " + name + "\nRun: npm install");
      }
      return path;
    };
    findPkg = function(it){
      return it.map(function(it){
        return {
          name: it,
          dest: dest,
          src: getPkgPath(
          it)
        };
      });
    };
    calculateChecksum = function(pkgPath, pkgInfo, done){
      return checksum(pkgPath, function(err, hash){
        if (err) {
          throw new Error("Error while calculating checksum for package " + pkgInfo.name);
        }
        pkgInfo.checksum = hash;
        pkgInfo.dest = pkgInfo.dest;
        return done(null, pkgInfo);
      });
    };
    definePkgBindirInfo = function(pkgInfo, pkg){
      pkgInfo.type = 'binaries';
      pkgInfo.links = pkg.links;
      files.push(
      pkgInfo);
      return pkgInfo;
    };
    definePkgDependencyInfo = function(pkgInfo, pkg, done){
      if (globals.indexOf(
      pkg.name) !== -1) {
        pkgInfo.dest = ".node/lib/node/" + pkg.name;
        pkgInfo.type = 'global-dependency';
      } else {
        pkgInfo.dest = getModulePath(
        pkg.name);
        pkgInfo.type = 'dependency';
      }
      emitter.emit('archive', pkgInfo);
      return calculateChecksum(pkg.path, pkgInfo, function(err, pkgInfo){
        files.push(
        pkgInfo);
        return done.apply(this, arguments);
      });
    };
    definePkgInfo = function(pkg, done){
      var pkgInfo;
      pkgInfo = {
        name: pkg.name
      };
      if (pkg.file) {
        pkgInfo.archive = pkg.file;
      }
      if (pkg.name === BINDIR) {
        return done(null, definePkgBindirInfo(pkgInfo, pkg));
      } else {
        return definePkgDependencyInfo(pkgInfo, pkg, done);
      }
    };
    doPack = function(options, done){
      if (options.name === BINDIR) {
        return done(null, options);
      } else {
        return pack(
        options).on('error', done).on('entry', onEntry).on('end', function(it){
          return done(null, it);
        });
      }
    };
    compressDepPkgs = function(pkgs, done){
      return fw.map(pkgs, doPack, function(err, results){
        if (err) {
          return done(
          err);
        }
        return fw.map(results, definePkgInfo, done);
      });
    };
    findGlobal = function(name){
      var module, jsonPath, pkg, src;
      module = resolve(
      name);
      if (!module) {
        throw new Error("Cannot find global dependency: " + name);
      }
      if (jsonPath = discoverPkg(
      dirname(
      module))) {
        if (pkg = read(
        jsonPath)) {
          globals.push(
          pkg.name);
          src = dirname(
          jsonPath);
          return {
            name: pkg.name,
            dest: dest,
            src: src
          };
        }
      }
    };
    processGlobal = function(globals){
      return vals(
      globals).filter(isValid).map(findGlobal);
    };
    processDeps = function(deps){
      deps = vals(
      deps).filter(isValid).map(findPkg).filter(isValid);
      if (deps.length) {
        addBinDirectory(
        deps[0]);
      }
      return deps;
    };
    dependenciesList = function(){
      var ref$, run, dev, peer, global, list;
      ref$ = matchDependencies(options, pkg), run = ref$.run, dev = ref$.dev, peer = ref$.peer, global = ref$.global;
      list = processDeps(
      {
        run: run,
        dev: dev,
        peer: peer
      });
      if (global) {
        list = list.concat([processGlobal(
        global)]);
      }
      return list;
    };
    list = dependenciesList();
    if (list.length) {
      return fw.each(list, compressDepPkgs, (function(it){
        return cb(it, files);
      }));
    } else {
      return cb();
    }
  };
  try {
    doCreate();
  } catch (e$) {
    e = e$;
    onError(
    e);
  }
  return emitter;
};
writeConfig = function(config, tmpdir, cb){
  var file, data;
  file = join(tmpdir, narFile);
  data = stringify(
  config);
  return fs.writeFile(file, data, cb);
};
narManifest = function(name, pkg){
  var platform, arch, version;
  platform = process.platform, arch = process.arch, version = process.version;
  return {
    name: name,
    time: now(),
    binary: false,
    info: {
      platform: platform,
      arch: arch,
      version: version
    },
    manifest: pkg,
    files: []
  };
};
includeFilesPatterns = function(dir, ignore){
  var patterns;
  patterns = ['**'].concat(ignoredFiles);
  if (ignore) {
    patterns = patterns.concat(getIgnoredFiles(
    dir));
  }
  return patterns;
};
getIgnoredFiles = function(dir){
  var patterns, files, ignored;
  patterns = [];
  files = ignoreFiles.map((function(it){
    return join(dir, it);
  })).filter((function(it){
    return exists(it);
  }));
  if (files.length > 1) {
    files = files.slice(-1);
  }
  if (files.length) {
    ignored = lines(
    read(
    files[0]));
    if (isArray(
    ignored)) {
      patterns = ignored.filter(function(it){
        return it;
      }).map(function(it){
        if (isDir(
        join(dir, it))) {
          return it + "/**";
        } else {
          return it;
        }
      }).map(function(it){
        return "!" + it.trim();
      });
    }
  }
  patterns = patterns.concat(ignoreFiles.map(function(it){
    return "!" + it;
  }));
  return patterns;
};
isValid = function(it){
  return it && it.length;
};
outputFile = function(file, dir){
  return join(dir, file + ".nar");
};
getFilename = function(options, pkg){
  var file, binary, name;
  pkg == null && (pkg = {});
  file = options.file, binary = options.binary;
  if (file) {
    name = file.replace(/\.[a-z0-9]$/i, '');
  } else {
    name = pkg.name || 'unnamed';
    if (pkg.version) {
      name += "-" + pkg.version;
    }
  }
  if (binary && !options.executable) {
    name += "-" + process.platform + "-" + process.arch;
  }
  return name;
};
applyPkgOptions = function(options, pkg){
  return extend(options, pkg.archive);
};
apply = function(options){
  var pkgPath;
  options = extend(clone(
  defaults), options);
  options.patterns || (options.patterns = []);
  if (options.path) {
    pkgPath = resolvePkgPath(
    options.path);
  } else {
    pkgPath = process.cwd();
  }
  options.binaryPath = getBinaryPath(
  options);
  options.path = discoverPkg(
  pkgPath);
  if (!options.dest) {
    options.dest = process.cwd();
  }
  return options;
};
resolvePkgPath = function(it){
  if (isFile(
  it)) {
    return resolvePkgPath(
    dirname(
    it));
  } else {
    return it;
  }
};
getBinaryPath = function(options){
  var binary;
  binary = options.binaryPath;
  if (process.env.NAR_BINARY) {
    binary = process.env.NAR_BINARY;
  }
  return replaceEnvVars(
  normalize(
  binary));
};
getModulePath = function(it){
  if (it === BINDIR) {
    it = '.bin';
  }
  return join('node_modules', it);
};
matchDependencies = function(options, pkg){
  var dependencies, devDependencies, peerDependencies, globalDependencies, deps;
  dependencies = options.dependencies, devDependencies = options.devDependencies, peerDependencies = options.peerDependencies, globalDependencies = options.globalDependencies;
  deps = {};
  if (dependencies) {
    deps.run = keys(
    pkg.dependencies);
  }
  if (devDependencies) {
    deps.dev = keys(
    pkg.devDependencies);
  }
  if (peerDependencies) {
    deps.peer = keys(
    pkg.peerDependencies);
  }
  if (isArray(
  globalDependencies)) {
    deps.global = globalDependencies;
  }
  return deps;
};
