// Generated by LiveScript 1.3.1
var utils, extract, download, ncp, join, resolve, EventEmitter, ref$, symlinkSync, chmodSync, rm, mk, next, write, read, isWin, isString, isObject, isArray, replaceEnvVars, isFile, isUrl, isDir, clone, extend, tmpdir, discoverPkg, winBinaryScript, defaults, install, apply, save, writeJson;
utils = require('./utils');
extract = require('./extract');
download = require('./download');
ncp = require('ncp').ncp;
join = require('path').join;
resolve = require('requireg').resolve;
EventEmitter = require('events').EventEmitter;
ref$ = require('fs'), symlinkSync = ref$.symlinkSync, chmodSync = ref$.chmodSync;
rm = utils.rm, mk = utils.mk, next = utils.next, write = utils.write, read = utils.read, isWin = utils.isWin, isString = utils.isString, isObject = utils.isObject, isArray = utils.isArray, replaceEnvVars = utils.replaceEnvVars, isFile = utils.isFile, isUrl = utils.isUrl, isDir = utils.isDir, clone = utils.clone, extend = utils.extend, tmpdir = utils.tmpdir, discoverPkg = utils.discoverPkg, winBinaryScript = utils.winBinaryScript;
defaults = {
  gzip: true,
  dest: null,
  clean: true,
  save: false,
  saveDev: false,
  savePeer: false,
  global: false
};
module.exports = install = function(options){
  var ref$, path, url, dest, clean, global, emitter, output, pkgInfo, tmp, cleanDir, onError, onEntry, onDownload, onProgress, onArchive, onDownloadEnd, onEnd, onExtract, getInstallPath, copy, createBinDir, setExecutionPerms, createLink, createBinary, processBinaries, extractor, downloader, doInstall, e;
  ref$ = options = apply(
  options), path = ref$.path, url = ref$.url, dest = ref$.dest, clean = ref$.clean, global = ref$.global;
  emitter = new EventEmitter;
  output = null;
  pkgInfo = {};
  tmp = tmpdir(
  path);
  cleanDir = function(){
    try {
      if (isDir(
      tmp)) {
        rm(tmp);
      }
      if (clean && output) {
        return rm(output);
      }
    } catch (e$) {}
  };
  onError = function(err, code, cmd){
    cleanDir();
    return emitter.emit('error', err, code, cmd);
  };
  onEntry = function(entry){
    if (entry) {
      return emitter.emit('entry', entry);
    }
  };
  onDownload = function(){
    return emitter.emit('download');
  };
  onProgress = function(it){
    return emitter.emit('progress', it);
  };
  onArchive = function(it){
    pkgInfo = it;
    return emitter.emit('archive', it);
  };
  onDownloadEnd = function(it){
    return emitter.emit('downloadEnd', it);
  };
  onEnd = function(output){
    save(
    options);
    cleanDir();
    return emitter.emit('end', output, options);
  };
  onExtract = function(it){
    if (options.dest === tmp) {
      return copy();
    } else {
      return onEnd(
      it);
    }
  };
  getInstallPath = function(){
    var dest;
    if (global) {
      dest = resolve('npm');
      if (dest) {
        return dest = join(dest, '../../../', pkgInfo.name || 'pkg');
      } else {
        return onError(
        new Error('Cannot resolve global installation path'));
      }
    } else {
      return dest = join(process.cwd(), 'node_modules', pkgInfo.name || 'pkg');
    }
  };
  copy = function(){
    var dest;
    dest = getInstallPath();
    if (!isDir(
    dest)) {
      mk(dest);
    }
    return ncp(tmp, dest, function(err){
      if (err) {
        return onError(
        err);
      }
      processBinaries(
      dest);
      return onEnd(
      {
        dest: dest
      });
    });
  };
  createBinDir = function(dir){
    if (!isDir(
    dir)) {
      return mk(dir);
    }
  };
  setExecutionPerms = function(file){
    try {
      return chmodSync(file, '775');
    } catch (e$) {}
  };
  createLink = function(binPath, dest){
    if (isWin) {
      return write(dest + ".cmd", winBinaryScript(
      binPath));
    } else {
      symlinkSync(binPath, dest);
      return setExecutionPerms(
      dest);
    }
  };
  createBinary = function(dest, path, name){
    var binPath, root;
    binPath = join(dest, path);
    if (isFile(
    binPath)) {
      if (global) {
        root = join(dest, '../../../', 'bin');
        createBinDir(root);
        return createLink(binPath, join(root, name));
      } else {
        root = join(dest, '../', '.bin');
        createBinDir(root);
        return createLink(binPath, join(root, name));
      }
    }
  };
  processBinaries = function(dest){
    var pkg, bin, name, path, own$ = {}.hasOwnProperty, results$ = [];
    pkg = join(dest, 'package.json');
    if (isFile(
    pkg)) {
      bin = (pkg = read(
      pkg)).bin;
      if (isString(
      bin)) {
        return createBinary(dest, bin, pkg.name);
      } else if (isObject(
      bin)) {
        for (name in bin) if (own$.call(bin, name)) {
          path = bin[name];
          if (path) {
            results$.push(createBinary(dest, path, name));
          }
        }
        return results$;
      }
    }
  };
  extractor = function(path){
    emitter.emit(
    'start');
    options.path = path;
    options.dest || (options.dest = tmp);
    return extract(
    options).on('error', onError).on('entry', onEntry).on('archive', onArchive).on('end', onExtract);
  };
  downloader = function(){
    if (!url) {
      options.url = path;
    }
    return download(
    options).on('download', onDownload).on('progress', onProgress).on('error', onError).on('end', function(it){
      output = it;
      onDownloadEnd(
      output);
      return extractor(
      output);
    });
  };
  doInstall = function(){
    return next(function(){
      if (url || isUrl(
      path)) {
        return downloader();
      } else {
        return extractor(
        path);
      }
    });
  };
  try {
    doInstall();
  } catch (e$) {
    e = e$;
    onError(
    "Cannot install: " + e);
  }
  return emitter;
};
apply = function(options){
  return extend(clone(
  defaults), options);
};
save = function(options){
  var save, saveDev, savePeer, pkgPath, pkg, pkgInfo, ref$, name, version;
  save = options.save, saveDev = options.saveDev, savePeer = options.savePeer;
  pkgPath = discoverPkg();
  if (pkgPath) {
    pkg = read(
    pkgPath);
    pkgInfo = read(
    join(options.dest, '.nar.json'));
    ref$ = pkgInfo.manifest, name = ref$.name, version = ref$.version;
    if (name && version) {
      if (save) {
        pkg.dependencies || (pkg.dependencies = {});
        if (!pkg.dependencies[name]) {
          pkg.dependencies[name] = "~" + version;
        }
      }
      if (saveDev) {
        pkg.devDependencies || (pkg.devDependencies = {});
        if (!pkg.devDependencies[name]) {
          pkg.devDependencies[name] = "~" + version;
        }
      }
      if (savePeer) {
        pkg.peerDependencies || (pkg.peerDependencies = {});
        if (!pkg.peerDependencies[name]) {
          pkg.peerDependencies[name] = "~" + version;
        }
      }
    }
  }
  return writeJson(pkgPath, pkg);
};
writeJson = function(path, pkg){
  return write(path, JSON.stringify(pkg, null, 2));
};
