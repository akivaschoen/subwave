// Generated by LiveScript 1.3.1
var fw, utils, unpack, EventEmitter, findup, ref$, symlinkSync, chmodSync, readdirSync, join, dirname, normalize, sep, relative, next, copy, isFile, isDir, tmpdir, rm, mk, read, write, clone, addExtension, isExecutable, executableMsg, isWin, isString, isObject, winBinaryScript, extract, apply, mkDirs, normalizePath;
fw = require('fw');
utils = require('./utils');
unpack = require('./unpack');
EventEmitter = require('events').EventEmitter;
findup = require('findup-sync');
ref$ = require('fs'), symlinkSync = ref$.symlinkSync, chmodSync = ref$.chmodSync, readdirSync = ref$.readdirSync;
ref$ = require('path'), join = ref$.join, dirname = ref$.dirname, normalize = ref$.normalize, sep = ref$.sep, relative = ref$.relative;
next = utils.next, copy = utils.copy, isFile = utils.isFile, isDir = utils.isDir, tmpdir = utils.tmpdir, rm = utils.rm, mk = utils.mk, read = utils.read, write = utils.write, clone = utils.clone, addExtension = utils.addExtension, isExecutable = utils.isExecutable, executableMsg = utils.executableMsg, isWin = utils.isWin, isString = utils.isString, isObject = utils.isObject, winBinaryScript = utils.winBinaryScript;
module.exports = extract = function(options){
  var ref$, path, dest, tmpdir, emitter, errored, clean, cleanError, onEnd, onEntry, onMsg, onError, extractor, extractorFn, copyBinFn, createSymlinks, getExtractFiles, extractArchives, copyNarJson, setExecutionPerms, extractNar, extractTasks, doExtract, e;
  options == null && (options = {});
  ref$ = options = apply(
  options), path = ref$.path, dest = ref$.dest, tmpdir = ref$.tmpdir;
  emitter = new EventEmitter;
  errored = false;
  clean = function(){
    try {
      return rm(tmpdir);
    } catch (e$) {}
  };
  cleanError = function(){
    clean();
    try {
      if (dest !== process.cwd()) {
        return rm(dest);
      }
    } catch (e$) {}
  };
  onEnd = function(){
    clean();
    if (!errored) {
      return emitter.emit('end', options);
    }
  };
  onEntry = function(entry){
    if (entry) {
      return emitter.emit('entry', entry);
    }
  };
  onMsg = function(msg){
    if (msg) {
      return emitter.emit('message', msg);
    }
  };
  onError = function(err){
    cleanError();
    if (!errored) {
      emitter.emit('error', err);
    }
    return errored = true;
  };
  extractor = function(options, type){
    return function(done){
      var path, dest, createLink, processGlobalBinaries, extractEnd;
      path = options.path, dest = options.dest;
      if (!isFile(
      path)) {
        return onError(
        new Error('The given path is not a file'));
      }
      if (isExecutable(
      path)) {
        return onError(
        executableMsg(
        path));
      }
      createLink = function(name, path){
        var binPath, root, binDir, binFile;
        binPath = join(dest, path);
        if (isFile(
        binPath)) {
          if (root = findup('package.json', {
            cwd: dirname(
            binPath)
          })) {
            binDir = join(dirname(
            root), '../../../', 'bin');
            binFile = join(binDir, name);
            if (!isDir(
            binDir)) {
              mk(binDir);
            }
            if (isWin) {
              return write(binFile + ".cmd", winBinaryScript(
              binPath));
            } else {
              return symlinkSync(binPath, binFile);
            }
          }
        }
      };
      processGlobalBinaries = function(pkg){
        var bin, name, path, own$ = {}.hasOwnProperty, results$ = [];
        bin = pkg.bin;
        if (isString(
        bin)) {
          return createLink(pkg.name, bin);
        } else if (isObject(
        bin)) {
          for (name in bin) if (own$.call(bin, name)) {
            path = bin[name];
            if (path) {
              results$.push(createLink(name, path));
            }
          }
          return results$;
        }
      };
      extractEnd = function(){
        var pkg;
        if (type === 'global-dependency') {
          pkg = read(
          join(dest, 'package.json'));
          if (pkg) {
            processGlobalBinaries(
            pkg);
          }
        }
        return done();
      };
      return function(){
        if (!isDir(
        dest)) {
          mk(
          dest);
        }
        return unpack(
        options).on('error', onError).on('entry', onEntry).on('end', extractEnd);
      }();
    };
  };
  extractorFn = function(it){
    var options;
    options = {
      gzip: false,
      path: join(tmpdir, it.archive),
      dest: normalizePath(
      join(dest, it.dest)),
      checksum: it.checksum
    };
    return extractor(options, it.type);
  };
  copyBinFn = function(options){
    return function(done){
      var origin, target;
      origin = join(tmpdir, options.archive);
      target = normalizePath(
      join(dest, options.dest));
      if (!isDir(
      target)) {
        mk(target);
      }
      return copy(origin, target, done);
    };
  };
  createSymlinks = function(files){
    return function(done){
      var links, base, cwd, name, link, own$ = {}.hasOwnProperty;
      links = files.links;
      base = join(dest, 'node_modules', '.bin');
      cwd = process.cwd();
      mk(
      base);
      process.chdir(
      base);
      for (name in links) if (own$.call(links, name)) {
        link = links[name];
        if (isFile(
        link) && !isFile(
        name)) {
          symlinkSync(link, name);
        }
      }
      process.chdir(
      cwd);
      return done();
    };
  };
  getExtractFiles = function(nar){
    var tasks, links;
    tasks = [];
    links = null;
    nar.files.forEach(function(it){
      if (it.type !== 'binaries') {
        emitter.emit('archive', it);
      }
      if (it.type === 'binary') {
        return tasks.push(
        copyBinFn(
        it));
      } else if (it.type === 'binaries') {
        return links = it;
      } else {
        return tasks.push(
        extractorFn(
        it));
      }
    });
    if (links) {
      tasks.push(
      createSymlinks(
      links));
    }
    return tasks;
  };
  extractArchives = function(done){
    var nar;
    nar = read(
    join(tmpdir, '.nar.json'));
    emitter.emit('info', nar);
    return fw.series(getExtractFiles(
    nar), done);
  };
  copyNarJson = function(done){
    var origin;
    origin = join(tmpdir, '.nar.json');
    return copy(origin, dest, function(err){
      if (err) {
        return onError(
        err);
      }
      return done();
    });
  };
  setExecutionPerms = function(){
    var depsBinDir, binDir;
    depsBinDir = join(dest, 'node_modules', '.bin');
    binDir = join(dest, 'bin');
    return [binDir, depsBinDir].filter((function(it){
      return isDir(it);
    })).forEach(function(dir){
      return readdirSync(
      dir).forEach(function(it){
        try {
          return chmodSync(join(dir, it), '775');
        } catch (e$) {}
      });
    });
  };
  extractNar = function(){
    var config;
    config = clone(
    options);
    config.dest = tmpdir;
    return extractor(
    config);
  }();
  extractTasks = function(){
    return fw.series([extractNar, extractArchives, copyNarJson], function(err){
      if (err) {
        return onError(
        err);
      }
      setExecutionPerms();
      return onEnd();
    });
  };
  doExtract = function(){
    return next(function(){
      mkDirs(dest, tmpdir);
      emitter.emit('start', dest);
      return extractTasks();
    });
  };
  try {
    doExtract();
  } catch (e$) {
    e = e$;
    onError(
    e);
  }
  return emitter;
};
apply = function(options){
  return {
    gzip: true,
    tmpdir: tmpdir(),
    dest: options.dest || process.cwd(),
    path: addExtension(
    options.path)
  };
};
mkDirs = function(dest, tmpdir){
  if (!isDir(
  dest)) {
    mk(dest);
  }
  if (!isDir(
  tmpdir)) {
    return mk(tmpdir);
  }
};
normalizePath = function(path){
  if (path) {
    return path.replace(new RegExp('\\\\', 'g'), '/');
  }
};
